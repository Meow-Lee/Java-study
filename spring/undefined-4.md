---
description: Chapter 10
---

# 애플리케이션 보안

* 인증과 인가(권한 부여)의 개념을 이해해야 보안 애플리케이션을 구축하고 사용자 확인과 접근 제어를 위한 기반을 마련할 수 있음
* 스프링 시큐리티는 인증과 인가를 위한 옵션을 HTTP 방화벽, 필터 체인, IETF와 W3C표준의 광범위한 사용, 교환 옵션과 같은 매커니즘과 결합해 애플리케이션 보안성을 높임
* 스프링 시큐리티는 바로 사용 가능한 동시에 보안을 중시하는 사고방식을 채택

## 인증 및 인가 부여

#### 인증

* 어떤 것(가령, 신원, 예술 작품 또는 금융 거래)을 실제, 사실 또는 진짜로 보여주는 행위, 프로세스나 방법, 무언가를 입증하는 행위나 과정
* 간단히 말해, 누군가가 자신이 주장하는 바로 그 사람인지 증명하는 것

#### 인가(권한 부여)

* 권한을 부여하는 행위(더 많은 정보에 권한을 부여하는 것을 의미)
* 권한을 부여하는 수단
* 일단 사용자가 인증을 받으면, 한 명 이상의 개인에게 허용된 사용 가능한 리소스 및 작업에 접근할 수 있음
* 개인은 신원이 입증되면 애플리케이션에 대한 일반 수준의 접근 인가를 얻음
* 이제 인증된 애플리케이션 사용자는 무언가에 대한 접근을 요청, 애플리케이션은 해당 리소스에 대한 사용자의 접근 아니면 인가 여부를 어떻게든 결정
* 사용자의 인가가 확인되면 사용자에게 접근 권한 부여, 그렇지 않으면 요청 거절을 사용자에게 알림

## 스프링 시큐리티

* 인증과 인가를 위한 확실한 옵션을 제공하고 개발자가 스프링부트 애플리케이션 보안 수준을 제고하는 데 도움되는 매커니즘 제공

### HTTP 방화벽

* 많은 보안 문제가 잘못된 URI를 사용한 요청과 이에 대한 시스템의 예기치 못한 응답에서 비롯됨
* 잘못된 헤더값이나 형식 등 요청에 문제가 있는 경우, 요청을 폐기
* 오버라이드하지 않는 한, 사용되는 기본 구현은 StrictHttpFirewall로, 애플리케이션의 보안 프로필에서 악용될 만한 가장 쉬운 빈틈을 메움

### 보안 필터 체인

* 인바운드 요청에 더 구체적이고 한 단계 더 높은 수준의 필터를 제공하는 스프링 시큐리티는 HTTP 방화벽을 통과한, 즉 제대로 형성된 요청을 필터 체인을 사용해 처리
* 간단히 말해, 대부분의 애플리케이션에서 인바운드 요청이 개발자가 지정한 조건과 일치할 때까지 지나쳐버리게 하는 필터 체인의 조건을 설정
* 요청이 필터와 일치하면, 해당 조건을 평가하고 요청의 이행 여부 결정
* 예를 들어, 특정 API 엔드포인트에 대한 요청이 도착하고 필터 체인의 필터 조건과 일치하면, 사용자가 요청된 리소스에 접근할 수 있는 적절한 역할/인가가 있는지 확인
* 있다면 요청을 처리하고, 그렇지 않으면 일반적으로 HTTP 403 Forbidden 상태 코드와 함께 거부
* 만약 요청이 모든 필터와 일치하지 않고 지나치면, 요청은 삭제

## 스프링 시큐리티 폼 기반 인증 및 인가 구현

### 스프링 시큐리티 응답 헤더

* Cache-Control(캐시 제어) -> 사용자가 사이트에서 로그아웃하면, 적대적인 행위자가 단순히 브라우저의 '뒤로 버튼'을 클릭해 피해자의 인증 정보로 로그인 된 보안 사이트로 돌아가지 못하도록 캐싱을 무효화
* X-Content-Type-Options(콘텐츠 유형 옵션) -> 콘텐츠 스니핑을 비활성화하기 위해 nosniff로 설정됨
* 프레임 옵션 -> 브라우저가 iframe내에 콘텐츠를 표시하지 못하도록, X-Frame-Options 헤더는 DENY값으로 설정 / 클릭재킹이라고 불리는 공격은 보이지 않는 프레임이 보이는 컨트롤 위에 놓일 때 발생하며, 원하지 않는 작업을 시작해 사용자의 클릭을 하이재킹하게 됨
* 스프링 시큐리티는 기본적으로 프레임 지원을 비활성화하여 클릭재킹 공격 경로를 차단
* XSS 보호 -> XSS 공격으로부터 브라우저 보호를 활성화하기 위해 값을 1로 설정

### 인증 추가

* 스프링 시큐리티 인증 기능의 핵심은 UserDetailsService 개념
* UserDetailsService는 단일 메서드 loadUserByUsername(String username)가 있는 인터페이스로, 구현 시 UserDetails 인터페이스를 충족하는 객체를 반환하고, 이 인터페이스에서 주요 정보를 얻음
* 정보란, 사용자 이름, 비밀번호, 사용자에게 부여된 인가와 계정 상태 등
* 즉, UserDeatilsService가 UserDetails를 반환하는 한, 애플리케이션은 기본 구현의 세부 정보를 알 필요가 없음

```java
// UserDetailsService 빈을 생성하기 위해 빈 생성 메서드를 정의할 설정 클래스 생성
// 메서드 내에서, User 클래스의 builder() 메서드를 사용해 사용자 정보를 지정해서 UserDetails 인터페이스
// 요구사항을 구현하는 객체 생성 후, build()하고 지역 변수에 할당
// 학습용으로만 비밀번호 로깅, 본래는 최악의 안티패턴임
// 마지막으로 User 객체들을 사용해 InMemoryUserDetailsManager를 생성하고 이를 스프링 빈으로 전환
// InMemoryUserDetailsManager는 UserDetailsManager와 UserDetailsPasswordService 인터페이스를
// 구현하여 특정 사용자가 있는지 여부 확인, 사용자의 생성/업데이트/삭제, 사용자 비밀번호의 수정/업데이트와 같은
// 사용자 관리 작업을 가능하게 함 
@Configuration
public class SecurityConfig {
    @Bean
    UserDetailsService authentication(){
        UserDetails peter = User.builder()
                .username("peter")
                .password("ppassword")
                .roles("USER")
                .build();

        UserDetails jodie = User.builder()
                .username("jodie")
                .password("jpassword")
                .roles("USER", "ADMIN")
                .build();

        System.out.println(">>> Peter's password: " + peter.getPassword());
        System.out.println(">>> Jodie's password: " + jodie.getPassword());

        return new InMemoryUserDetailsManager(peter, jodie);
    }
}

// 이 후, 로그인을 해보면 다음과 같은 오류로 트러블 슈팅이 필요함
// There is no PasswordEncoder mapped for the id "null"
// ppassword/jpassword와 같은 비밀번호는 인코딩되지 않은 일반 텍스트
// 당연히 비밀번호인만큼 암호화를 하기 위해 인코딩이 필요, 따라서
// 동작하는, 보안성 있는 인증을 위해서 비밀번호 인코더를 추가
private final PasswordEncoder pwEncoder = 
        PasswordEncoderFactories.createDelegatingPasswordEncoder();
        
// 보안 애플리케이션 생성과 유지, 관리에 수반되는 어려움으로 보안의 지속적인 진화가 필연적이므로
// 스프링 시큐리티에는 단순히 플러그인하는 지정된 인코더가 없음
// 대신 사용 가능한 여러 인코더가 있는 팩토리를 사용하고, 인코딩과 디코딩을 하기 위해 하나의 인코더에 위임
// 위와 같이 지정된 인코더가 없을 경우, 기본값을 설정된 인코더가 사용되는데, 현재 BCrypt는 기본값으로 훌륭함
// 하지만, 스프링 시큐리티 인코더 아키텍처의 위임된 유연한 특성은 표준이 발전되거나 요구사항이 변경될 때
// 인코더를 다른 인코더로 쉽게 교체할 수 있다는 점
// 이러한 접근 방식은 애플리케이션 사용자가 애플리케이션에 로그인 할 때 한 인코더에서 다른 인코더로 사용자 자격 증명을
// 마찰없이 마이그레이션하므로, 조직에 직접적으로 가치를 부여하진 않지만, 마이그레이션 작업량을 줄여줌
// 마이그레이션이란, 구버전에서 신버전으로의 이전 또는 업그레이드를 의미

// 이 후, 인코더를 사용해 사용자 비밀번호를 암호화 / encode()메서드에 일반텍스트로 된 비밀번호 전달 후 호출하면
// 암호화된 결과 반환

// cf) 모든 인코더가 암호화하지는 않음. 예를 들어 해싱은 값을 인코딩하지만 반드시 암호화하지 않음
// 따라서 늘 현재 권장되는 스프링 시큐리티 인코더를 선택하거나 createDelegationPasswordEncoder() 제공 기본 인코더 선택

>>> Peter's password: {bcrypt}$2a$10$tgmvW89VBdHm02giitUb/O.h9dOEQwGC46H.O6f.O.Orrs6HEYlti
>>> Jodie's password: {bcrypt}$2a$10$KMAdYn6O1.cPW/DrYXv6oOaFVFXXMlg5dY4dPE4.G7FleIrjtxno.
```

#### 인코딩된 비밀번호 형식

* 편의를 위해 스프링 시큐리티는 어떤 알고리즘이 사용됐는지를 나타내는 키를 인코딩된 값 앞에 추가
* 이럴 경우, 키값이 알고리즘을 나타내니 복호화하기 더 쉽지 않을까 하는 의문이 들 수 있음
* 하지만, 암호 자체에 보안성이 있기 때문에 그렇지 않음

### 인가

*
