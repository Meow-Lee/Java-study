---
description: 그림과 실습으로 배우는 도커 & 쿠버네티스
---

# 실전에 활용가능한 컨테이너 사용법

## <필요한 지식이 무엇인지 정리하기>

## 역할에 따라 알아야 할 지식이 달라짐

* 서버 엔지니어나 보안 엔지니어라면 도커를 깊이 공부해야함 ( 도커 공식 참조문서 활용)

## 앞으로 설명할 도커 기술

* 컨테이너와 호스트 사이에 파일 복사
* 볼륨 마운트 (바인드 마운트, 볼륨 마운트)
* 컨테이너를 이미지로 만들기
* 컨테이너 개조
* 도커 허브 로그인 -> 자신이 직접 만든 컨테이너를 다른 사람에게 공개하기 위해 사용하는 서비스
* 도커 컴포즈 (다음 장)
* 쿠버네티스(다다음 장) -> 여러 대의 서버에서 컨테이너를 실행할 때 사용하는 컨테이너 오케스트레이션 도구

## <컨테이너와 호스트 간에 파일 복사>

## 파일 복사

* 프로그램 외에도 프로그래밍 언어의 런타임이나 데이터베이스, 웹서버 등이 함께 시스템을 구성
* 구성 요소는 시스템이 동작하는 데 필요하지만 그 외에도 화면을 구성하는 이미지, 입력받은 데이터 본체 등이 있을 수 있음
* 이러한 파일들은 때로는 소프트웨어의 개입 없이 서버와 로컬 컴퓨터 간에 파일을 주고받아야 할 때가 있음
* 이런 상황에 파일 복사 방법을 사용
* 파일 복사는 컨테이너->호스트(도커 엔진을 실행 중인 PC), 호스트->컨테이너 양방향 모두 가능함

### 파일 복사 커맨드 docker cp (docker container cp)

* docker cp \[호스트 경로] \[컨테이너 이름]:\[컨테이너 경로] (호스트->컨테이너)
* docker cp \[컨테이너 이름]:\[컨테이너 경로] \[호스트 경로] (컨테이너->호스트)
* 즉, docekr cp \[원본\_경로] \[복사할\_경로]

### 호스트 경로의 예

* 호스트(도커 엔진을 실행하는 PC) 내 파일 위치는 어디든 괜찮음
* 파일의 위치는 '경로' 형태로 작성하는데, 경로는 컴퓨터 속 파일이나 폴더(디렉토리)의 주소를 나타냄
* 예로, 윈도우는 C:\Users\사용자명\Documents\파일명

### index.html 파일 만들기

* 아파치 컨테이너를 예로 들면, 아파치에 접근하면 초기 화면이 표시되는데, index.html 파일을 만들면 이 파일의 내용이 초기 화면보다 우선시 됨

## <볼륨 마운트>

## 볼륨과 마운트

* 볼륨이란, 스토리지의 한 영역을 분할한 것을 말함
* 간단히 말해서, 하드디스크나 SSD를 카스테라라고 했을 때 카스테라를 자른 한 조각을 볼륨이라고 생각하면 됨
* 마운트란, 연결하다라는 의미 그대로 대상을 연결해 운영체제 또는 소프트웨어의 관리하에 두는 일을 말함
* 간단히 말해서, USB 메모리를 컴퓨터에 꽂으면 폴더가 열리는데, 이것은 USB 메모리가 컴퓨터에 마운트 되었다고 함
* 마운트가 되지 않으면 컨테이너가 외부에 있는 데이터를 다룰 수 없고, 되었다면 외부에 있는 데이터를 다룰 수 있음
* 지금까지 컨테이너를 생성하고 다루는 법을 배워왔는데, 실제로 컨테이너를 사용하려면 데이터가 스토리지에 있기 때문에 스토리지 영역을 마운트해야 함
* 컨테이너를 종료해도 바로 삭제되지는 않지만 성격상 '쓰고 버려야' 하기 때문에 소프트웨어 업그레이드 등의 이유로 언젠가는 삭제됨
* 이런 상황에서 데이터가 컨테이너에 있다면 데이터도 같이 소멸됨
* 이 때문에 컨테이너 역시 외부로 데이터를 대피시키는데, 컨테이너는 생성 및 폐기가 매우 빈번하므로 매번 데이터를 옮기는 대신 처음부터 컨테이너 외부에 둔 데이터에 접근해 사용하는 것이 일반적임
* 이를 데이터 퍼시스턴시(data persistency)라 하고, 데이터를 두는 장소가 마운트된 스토리지 영역임

## 스토리지 마운트의 종류

* 볼륨 마운트, 바인드 마운트

### 볼륨 마운트

* 도커 엔진이 관리하는 영역 내에 만들어진 볼륨을 컨테이너에 디스크 형태로 마운트 하는 것
* 이름만으로 관리가 가능하므로 다루기 쉽지만 볼륨에 비해 직접 조작하기 어려워 **'임시 목적의 사용'** 또는 **'자주 쓰지는 않지만 지우면 안 되는 파일'**을 두는 목적으로 많이 사용함함

### 바인드 마운트

* 도커가 설치된 컴퓨터의 문서 폴더 또는 바탕화면 폴더 등 도커 엔진에서 관리하지 않는 영역의 기존 디렉터리를 컨테이너에 마운트하는 방식
* 파일 단위로도 마운트가 가능함
* 폴더 속 파일을 직접 두거나 열어볼 수 있기 때문에 자주 사용하는 파일을 두는 데 사용함

### 두가지 마운트 방식의 차이점

* 차이점의 포인트는 간단한지 복잡한지 / 호스트 컴퓨터에서 파일을 다룰 필요가 있는지 / 환경의 의존성을 배제해야 하는지 등 세가지
* 볼륨 마운트는 도커 엔진 관리하에 있으므로 사용자가 파일 위치를 신경쓸 필요가 없음
* 또한 운영체제에 따라 명령어가 달라지는 의존성 문제도 없음
* 즉, 익숙해지면 손쉽게 사용할 수 있음
* 하지만 도커 컨테이너를 경유하지 않고서는 직접 볼륨에 접근할 방법이 없고, 억지로 볼륨 수정 시 볼륨이 깨질 수 있을 뿐더러 백업도 복잡한 절차가 필요함
* 바인드 마운트는 도커가 관리하지 않는 영역 어디라도 파일을 둘 수 있고 기존과 동일한 방식으로 파일을 사용할 수 있음
* 도커 엔진과 무관함
* 워드프레스처럼 파일을 자주 편집해야 하는 경우에 바인드 마운트를 사용함
* 간단히 정리해보자면, 파일을 직접 편집해야 할 일이 많으면 바인드 마운트, 그렇지 않으면 볼륨 마운트를 권장

## 스토리지 영역을 마운트하는 커맨드

* 어느 마운트 방식을 사용하든 스토리지 마운트는 run 커맨드의 옵션 형태로 지정
* 마운트하려는 스토리지의 경로가 컨테이너 속 특정 경로와 연결되도록 설정하는 형태
* 예로들면, 바탕화면의 단축 아이콘과 같은 느낌으로 단축아이콘을 누르면 프로그램과 연결되는 느낌임

### 스토리지를 마운트하는 절차

* 먼저 마운트될 스토리지를 생성
* 볼륨 마운트의 경우 마운트와 동시에 볼륨을 만들 수도 있지만, 마운트 전에 별도로 볼륨을 먼저 생성하는 것이 좋음

### 스토리지 영역을 만드는 방법

* 바인드 마운트는 원본이 될 폴더나 파일을 먼저 만듬
* 볼륨 마운트는 볼륨 상위 커맨드를 사용해 먼저 볼륨 생성
* docker volume create/rm \[볼륨\_이름]

### 스토리지를 마운트하는 커맨드

* docker run -v \[스토리지 실제 경로]:\[컨테이너 마운트 경로] (바인드 마운트)
* docker run -v \[볼륨 이름]:\[컨테이너 마운트 경로] (볼륨 마운트)

## <컨테이너로 이미지 만들기>

## 컨테이너로 이미지를 만드는 방법

* 이미 존재하는 컨테이너를 이용하면 누구나 쉽게 이미지를 만들 수 있음
* 자신만의 이미지를 만들어 똑같은 구성의 컨테이너를 대량으로 만들고, 다른 컴퓨터 또는 서버에 이동시킬수도 있음
* 이미지를 만드는 방법에는 두 가지가 있음
* 첫번째는 commit 커맨드로 기존 컨테이너를 이미지로 변환하는 방법이고, 두번째는 Dockerfile 스크립트로 이미지를 만드는 방법

### commit 커맨드로 컨테이너를 이미지로 변환

* 컨테이너를 준비하고 컨테이너를 이미지로 변환
* 컨테이너만 있으면 명령어 한번으로 이미지를 만들 수 있어 간편하지만 컨테이너를 먼저 만들어야 함
* 기존 컨테이너를 복제하거나 이동해야 할 때 편리함
* docker commit \[컨테이너 이름] \[새로운  이미지  이름]

### Dockerfile 스크립트로 이미지 만들기

* Dockerfile 스크립트를 작성하고 이 스크립트를 빌드해 이미지를 만드는 방법
* 이미지를 만드는 것밖에 못하는 도커 이미지 파일 정도의 존재
* 스크립트에는 토대가 될 이미지나 실행할 명령어 등을 기재
* 이 파일을 컴퓨터의 이미지 재료가 들어있는 폴더에 넣고, 컨테이너에 넣을 파일을 함께 둠
* 실제 컨테이너를 만들 필요는 없음
* docker build -t \[생성할 이미지 이름] \[재료 폴더 경로]

#### Dockerfile 스크립트 예

```docker
// FROM 뒤에 이미지 이름 기재
// 그 뒤로는 파일 복사, 명령어 실행 등 컨테이너 대상으로 할 일을 기재
FROM 이미지_이름
COPY 원본_경로 대상_경로
RUN 리눅스_명령어
...
```

## <컨테이너 개조>

## 컨테이너 개조란?

* 도커를 실제 운용하는 현장에서는 사내에서 개발한 시스템을 운영하는 경우가 많음
* 사내 개발 시스템이 아니더라도 공식 배포되는 소프트웨어 역시 수정해야 할 필요가 종종 있음
* 큰 수정은 아니지만 설정 파일을 매번 작성하기는 귀찮기 때문

### 컨테이너를 개조하는 방법

* 파일 복사와 마운트를 이용한 방법
* 컨테이너에서 리눅스 명령어를 실행하는 방법

### 컨테이너에서 명령어를 실행하려면 shell이 필요

* 컨테이너에서 리눅스 명령어를 실행하려면 리눅스에 우리의 명령을 전달해주는 shell이 있어야함
* 대부분의 컨테이너에는 가장 일반적으로 사용되는 shell인 bash가 설치되어 있음
* 컨테이너를 아무 설정 없이 실행하면 bash가 동작하지 않는 상태로 실행됨
* bash를 실행하려면 /bin/bash 인자를 전달하면 됨
* 이 인자는 docker exec / docker run 과 함께 사용됨
* docker exec 는 컨테이너 속에서 명령어를 실행하는 커맨드
* 실행 중인 컨테이너에 run 커맨드를 사용할 수 없으므로 이 방법을 사용함
* 사실상 docker exec를 많이 사용하므로 exec 커맨드만 생각하면 됨
* docker exec \[옵션] \[컨테이너 이름] /bin/bash
* bash가 실행되면 shell에 입력된 명령은 도커 엔진이 아니라 해당 컨테이너로 전달됨
* bash를 통해 컨테이너 내부를 조작하는 동안에는 도커 명령을 사용할 수 없음
* 즉, 컨테이너를 만들고 삭제하거나 컨테이너 자체에 대한 명령은 도커 엔진을 통하고, 컨테이너 내부를 다루는 명령은 bash를 통함
* 그러므로 컨테이너 안에서 할 일을 마쳤다면 다시 컨테이너에서 나와야 함 -> exit 명령어 사용

## 도커의 구조, 도커 엔진을 통해야 하는 명령과 컨테이너 안에서 실행해야 하는 명령

### 도커 엔진진을 통한 명령과 컨테이너 내부에서 실행하는 명령

* 부모에 해당하는 도커 엔진을 통해야 하는 명령은 도커 엔진 자체의 시작, 종료, 네트워크, 디스크 설정, 실행 중인 컨테이너 목록 확인 등 컨테이너 전체에 대한 관리 작업
* 컨테이너 생성, 실행, 종료, 이미지 내려받기 등도 포함됨
* 반면, 컨테이너 내부에서 실행하는 명령은 컨테이너 속에 새로운 소프트웨어 추가, 실행, 종료, 설정 변경, 컨테이너 밖과 안의 파일 복사 및 이동, 삭제 작업

### 도커와 컨테이너는 별개의 언어를 사용

* 도커와 컨테이너는 부모 자식 같은 관계를 가지지만 별개의 존재이므로 상황에 따라 사용하는 언어가 달라지기도 함
* 컨테이너에 들어있는 운영체제 비슷한 것의 종류가 무엇이냐에 따라 컨테이너 내부에서 사용하는 명령어가 약간씩 달라지게 됨

## <도커 허브 등록 및 로그인>

## 이미지는 어디서 내려받는 것인가?

* 내려받은 이미지들은 도커 허브에 저장된 것
* 직접 만든 이미지도 도커 허브에 올릴 수 있고, 비공개로 사용하는 도커 허브 같은 장소도 만들 수 있음

## 도커 허브와 도커 레지스트리

* 이비지를 배포하는 장소를 도커 레지스트리라고 함
* 도커 허브는 도커 제작사에서 운영하는 공식 도커 레지스트리를 말함

### 레지스트리와 리포지토리

* 레지스트리(등록장부)와 리포지토리(창고)는 다른 개념임
* 레지스트리는 이미지를 배포하는 장소이고, 리포지토리는 레지스트리를 구성하는 단위임
* 레지스트리는 여러 개의 리포지토리가 있고 도커 허브는 여러 개의 레지스트리를 가짐

## 태그와 이미지 업로드

* 도커 허브에 공개 업로드든, 비공개 리포지토리에 업로드든 이미지를 업로드하려면 이미지에 태그를 부여해야함

### 이미지 이름과 태그

* 도커의 태그는 레지스트리에 업로드를 상정한 이미지 이름에 가까움
* 예로, 로컬에서 nyapa000ex22처럼 대충 붙였던 이름을 'zoozoo.coomm/nyapacchi:13'처럼 레지스트리의 주소와 버전 표기를 추가해 정식 명칭으로 만듬
* zoozoo.coomm -> 레지스트리 주소 / nyapacchi -> 리포지토리 이름 / 13 -> 버전
* 태그 = \[레지스트리주소(도커 허브는 ID)]/\[리포지토리이름]:\[버전]

### 이미지에 태그를 부여해 복제하는 커맨드 docker tag(docker image tag)

* 이미지에 태그를 부여하는 명령어
* 원래 있던 이미지 이름을 태그로 바꾸고 이미지를 복제하라는 의미
* docker tag \[원래 이미지 이름] \[레지스트리 주소]/\[리포지토리 이름]:\[버전]

### 이미지를 업로드하는 커맨드 docker push(docker image push)

* docker push는 이미지를 업로드하는 커맨드
* docker push \[레지스트리 주소]/\[리포지토리 이름]:\[버전]

## 레지스트리를 만드는 방법

* 대개 사내용 도커 레지스트리를 만들고 개발환경 이미지를 올려 배포하는 체계를 가지고 있을 것임

### 비공개 레지스트리 만드는 방법

* 레지스트리용 컨테이너가 따로 있으므로 도커를 통해 운영할 수 있음
* 컨테이너를 만들면 사용자는 레지스트리에 로그인한 다음 이미지를 내려받을 곳으로 이 레지스트리를 지정
* 레지스트리는 5000번 포트를 사용함
* docker run -d -p 5000:5000 registry

### 도커 허브 사용

* 이메일 주소만 있으면 도커 허브에 가입할 수 있음
