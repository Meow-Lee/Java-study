---
description: 그림과 실습으로 배우는 도커 & 쿠버네티스
---

# 쿠버네티스

## <쿠버네티스란?>

## 쿠버네티스란?

* 컨테이너 오케스트레이션 도구의 일종임
* 컨테이너 오케스트레이션이란 시스템 전체를 통괄하고 여러 개의 컨테이너를 관리하는 일을 말함
* 이름 그대로 오케스트라를 떠올리면 되는데, 지휘자가 악단을 지휘하듯 여러 개의 컨테이너를 지휘하는 도구가 쿠버네티스라고 생각하면 간단함
* k8s라고 줄여쓰기도 함

### 쿠버네티스를 일반적인 프로그래머가 관리하는 일은 드물다

* 대규모 시스템을 개발하는 프로그래머라도 대규모 서버군을 직접 관리할 일이 드물듯 쿠버네티스를 사용할 일도 드뭄
* 다만, 쿠버네티스로 어떤 일을 할 수 있는가에 대한 지식은 시스템을 개발할 때 유용할 수 있음
* 쿠버네티스로 관리되는 시스템은 이를 전제로 개발해야만 이점을 살릴 수 있음

### 여러 대의 컨테이너가 여러 대의 물리적 서버에 걸쳐 실행되는 것을 전제로 함

* 도커는 한 대의 물리적 서버에서 실행되는 경우가 많았지만 쿠버네티스는 여러 대의 물리적 서버가 존재하는 것을 전제로 함
* 또 서버 한 대마다 제각기 여러 대의 컨테이너를 실행
* 이렇게 여러 대의 서버에서 일일이 컨테이너들을 실행하고 관리하기가 어렵기 때문에 쿠버네티스를 사용함
* 도커 컴포즈에서 사용되는 정의 파일과 비슷한 정의 파일(메니페스트)만 작성하면 이 정의에 따라 모든 물리적 서버에 컨테이너를 생성하고, 생성한 컨테이너를 관리

## <마스터 노드와 워커 노드>

## 클러스터의 구성 - 마스터 노드와 워커 노드

* 쿠버네티스는 전체적인 제어를 담당하는 마스터 노드와 실제 동작을 담당하는 워커 노드라는 두 가지 유형의 노드로 구성
* 노드는 거의 물리적 서버와 일치하는 개념이라고 보면되는데, 구성하는 방법에 따라서 물리적 서버가 없을수도 있음
* 마스터 노드는 이름 그대로 감독과 같은 존재
* 마스터 노드에서 컨테이너를 실행하지는 않으며 워커 노드에서 실행되는 컨테이너를 관리하는 역할
* 워커 노드는 실제 서버에 해당하는 부분으로, 컨테이너가 실제 동작하는 서버
* 이렇게 마스터 노드와 워커 노드로 구성된 일군의 쿠버네티스 시스템을 클러스터라고 함
* 클러스터는 사람이 개입하지 않아도 마스터 노드에 설정된 내용에 따라 워커 노드가 관리되며 자율적으로 동작함

### 쿠버네티스를 사용하려면 먼저 설치가 필요함

* 쿠버네티스 소프트웨어와 CNI(가상 네트워크 드라이버)를 설치해야함
* 또 마스터 노드에는 컨테이너 등의 상태를 관리하기 위해 etcd(key-value db) 데이터베이스가 설치됨
* 워커 노드에는 물론 도커 엔진 같은 컨테이너 엔진이 필요함
* 마스터 노드를 설정하는 관리자 컴퓨터에는 kubectil을 설치하는데, 이것이 있어야 마스터 노드에 로그인해 초기 설정을 진행하거나 추후 조정이 가능

### 컨트롤 플레인(제어판)과 kube-let

* 마스터 노드는 컨트롤 플레인을 통해 워커 노드를 관리
* 총 다섯 가지의 컴포넌트로 구성되고, etcd와 쿠버네티스만 설치하면 설치 완료
* 마스터 노드측 컨트롤 플레인의 구성

<table><thead><tr><th width="246">항목</th><th>내용</th></tr></thead><tbody><tr><td>kube-apiserver</td><td>외부와 통신하는 프로세스, kubectl로부터 명령을 전달받아 실행</td></tr><tr><td>kube-controller-manager</td><td>컨트롤러를 통합 관리, 실행</td></tr><tr><td>kube-scheduler</td><td>파드를 워커 노드에 할당</td></tr><tr><td>cloud-controller-manager</td><td>클라우드 서비스와 연동해 서비스를 생성</td></tr><tr><td>etcd</td><td>클러스터 관련 정보 전반을 관리하는 데이터베이스</td></tr></tbody></table>

* 워커 노드에서는 kube-let과 kube-proxy가 동작
* kube-let은 마스터 노드의 kube-scheduler와 연동하며 워커 노드에 컨테이너 또는 볼륨을 배치하고 실행
* 워커 노드의 구성

<table><thead><tr><th width="134">항목</th><th>내용</th></tr></thead><tbody><tr><td>kube-let</td><td>마스터 노드에 있는 kube-scheduler와 연동하며 워커 노드에 파드를 배치하고 실행, 실행 중인 파드의 상태를 정기적으로 모니터링하며 kube-scheduler에 통지</td></tr><tr><td>kube-proxy</td><td>네트워크 통신의 라우팅 매커니즘</td></tr></tbody></table>

## 쿠버네티스는 항상 바람직한 상태를 유지

* 쿠버네티스도 컨테이너를 생성하거나 삭제할 수 있지만 일일이 명령어를 입력하는 거 보다는 컨테이너는 00개, 볼륨은 xx개로 구성하라 와 같이 바람직한 상태를 YAML에 정의
* 또한 자동으로 컨테이너를 생성하거나 삭제하면서 이 상태를 만들고 유지하는 것이 쿠버네티스의 기본 아이디어
* 도커 컴포즈는 옵션을 지정해 수동으로 컨테이너 수를 바꿀 수는 있어도 모니터링 기능이 없어서 컨테이너를 만들 때 외에는 관여하지 않고, 쿠버네티스는 이 상태를 유지하는 것이 가능
* 간단하게 말해서, 도커 컴포즈는 정의 파일 대로 컨테이너를 생성하면 끝이고, 쿠버네티스는 생성, 모니터링, 유지하는 것이 가능(도커 컴포즈도 가능은 함)

### 쿠버네티스를 사용하는 시스템에서 컨테이너 삭제

* 쿠버네티스의 기능은 어디까지나 자동으로 상태를 유지하는 것으로, 컨테이너를 삭제하고 싶다면 명령어를 입력하는 것이 아니라 파일에서 상태를 수정해야 함
* 또한, 바람직한 상태를 유지하는 것이므로, 사람이 개입해서 컨테이너를 삭제해서는 안됨
* 즉, 컨테이너를 모두 삭제하고 싶다면 필요한 컨테이너 수는 0이라고 지정하면 되는 것

## \*\* 로드 밸런서와 클라우드 컴퓨팅

* 쿠버네티스는 똑같은 서버를 여러 대 갖춰야하는 대규모 시스템을 전제로 함
* 로드 밸런싱이란, 한 대의 서버에 모든 요청이 집중되지 않도록 여러 대의 서버를 갖추고 요청을 각 서버에 분산하는 것
* 여러 대의 서버가 부하를 분담하여 과도한 부하가 걸린 서버가 망가지거나 처리가 늦어지는 것을 방지
* 요청을 이 서버에서 처리하세요 와 같이 각 서버에 나눠주는 역할이 필요한데, 이 역할을 맡는 장치가 로드 밸런서
* 하지만 서버에 들어오는 요청이 많을 때도 있고, 적을 때도 있기 때문에 서버가 많고 요청이 적으면 그만큼 비용이 낭비됨
* 이 문제를 해결하는 것이 도커와 쿠버네티스
* 부하에 맞춰 컨테이너를 늘리거나 줄일 수 있다면 놀고 있는 서버를 줄일 수 있기 때문
* 하지만, 여름만 요청이 많으니 봄,가을,겨울은 남는 서버를 끈다 는 식이면 낭비를 줄였다고 하기 어려운데, 이를 해결해주는 것이 AWS, GCP 같은 클라우드 서비스
* 여름에는 요청 수가 많으니 클라우드에서 서버를 늘리는 체제를 갖추면 다른 계절에 불필요하게 서버를 유지할 필요가 없음

## \*\* etcd의 역할

* 도커 컴포즈와 쿠버네티스의 가장 큰 차이점은 쿠버네티스의 정의 파일(메니페스트)이 데이터베이스로 관리된다는 것
* 쿠버네티스가 정의 파일을 읽어 들이면 그 내용은 etcd에 저장
* 파드는 이 정보를 근거로 관리되며, 쿠버네티스의 정의 파일은 커맨드로 수정이 가능
* 그러므로 쿠버네티스가 정의파일을 읽어들인 후 커맨드로 직접 컨테이너에 손을 대면, 갖고 있는 정의 파일과 etcd에 저장된 정보가 일치하지 않게 되므로 조심해야함

## <쿠버네티스의 구성과 관련 용어>

## 파드, 서비스, 디플로이먼트, 레플리카세트

### 파드 = 컨테이너와 볼륨을 함께 묶은 것

* 쿠버네티스에서 컨테이너는 파드(pod)라는 단위로 관리됨
* 파드는 컨테이너와 볼륨을 함께 묶은 것으로, 기본적으로 파드 하나가 컨테이너 하나이지만 여러 개인 파드도 있을 수 있음
* 파드에 포함되는 볼륨은 기본적으로 함께 파드에 포함되는 컨테이너가 정보를 공유하기 위해 사용하는 것으로, 파드에 볼륨이 없는 경우도 많음

### 파드가 모여 구성하는 서비스

* 파드를 모은 것이 서비스
* 여러 개의 파드를 이끄는 반장이라고 생각하면 됨
* 같은 종류의 파드를 하나의 서비스가 관리함
* 서비스의 역할은 쉽게 말해 로드 밸런서임
* 각 서비스는 자동적으로 고정된 IP 주소를 부여받으며(cluster IP), 이 주소로 들어오는 통신을 처리
* 내부적으로 여러 개의 파드가 있어도 밖에서는 하나의 IP 주소(cluster IP)만 볼 수 있고, 이 주소로 접근하면 서비스가 통신을 적절히 분배해주는 구조
* 서비스가 분배하는 통신은 한 워커 노드 안으로 국한됨
* 여러 워커 노드 간의 분배는 실제 로드 밸런서 또는 인그레스가 담당
* 즉, 로드 밸런서 또는 인그레스가 요청을 워커로 분배하고, 워커 안의 로드밸런서 역할을 하는 서비스가 요청을 적절히 분배하는 것

### 디플로이먼트와 레플리카세트

* 서비스가 요청을 배분하는 반장이라면, 레플리카세트는 파드의 수를 관리하는 반장
* 장애 등의 이유로 파드가 종료되었을때, 모자라는 파드를 보충하거나 정의 파일에 정의된 파드의 수가 감소하면 그만큼 파드의 수를 실제로 감소시킴
* 즉, 파드는 서비스와 레플리카세트, 두명의 반장에 의해 관리됨
* 레플리카세트가 관리하는 동일한 구성의 파드를 레플리카라고 부름
* 원하는 대로 다루기 어렵기 때문에 레플리카세트는 디플로이먼트와 함께 쓰일 때가 많음
* 디플로이먼트란 파드의 배포를 관리하는 요소로, 파드가 사용하는 이미지 등 파드에 대한 정보를 가지고 있음
* 레플리카세트가 반장이라면 디플로이먼트는 반장보다 위에 있는 상사

## <메니페스트 파일 작성>

## 매니페스트 파일이란?

* 쿠버네티스는 매니페스트 파일에 정의된 내용에 따라 파드를 생성
* 매니페스트 파일의 내용을 쿠버네티스에 업로드하면 etcd에 등록이 되고, 서버 환경을 이 상태로 유지함

### YAML 형식으로 메니페스트 파일 작성

* 파드나 서비스에 대한 설정을 쿠버네티스에서 매니페스트라고 함
* 이를 적은 파일은 매니페스트 파일이라고 하며, JSON 또는 YAML 형식으로 기재
* 사람이 설정 파일을 읽고 쓴다면 주로 YAML 파일 사용
* 컴포즈와 다르게 이름이 지정되어 있지는 않음

### 매니페스트 파일은 리소스 단위로 작성

* 리소스 단위로 작성하는데, 리소스는 파드나, 서비스, 디플로이먼트, 레플리카세트 등을 가리킴
* 파드 항목은 정말로 파드만을 만들 때 사용하는 항목으로, 이 항목에는 쿠버네티스 최대 특징인 자동으로 설정된 개수를 유지하는 기능이 없음
* 개수를 유지하는 기능은 디플로이먼트나 레플리카세트에서 담당하기 때문에 디플로이먼트를 만들어야하고, 레플리카세트 역시 디플로이먼트에서 개수를 관리하므로 항목으로 작성하지 않음
* 즉, 디플로이먼트 항목에 레플리카세트와 파드 항목이 포함되어 있는 것

### 매니페스트 파일은 여러 파일로 분할할 수 있음

* 리소스 단위로 분할해 작성해도 되고, 한 파일에 합쳐 작성해도 됨
* 한 파일로 작성할 때는 각 리소스를 --- 로 구분
* 리소스 단위로 파일을 나누면 각 리소스를 구별할 수 있도록 이름을 붙임 ex) apa000dep.yml , apa000ser.yml

## 매니페스트 파일로 작성할 내용

* 주 항목은 네가지로, apiVersion과 kind는 리소스를 정의하며, metadata는 메타데이터 작성, spec은 리소스의 내용을 작성하는 데 사용
* apiVersion: -> API그룹 및 버전
* kind: -> 리소스 유형
* metadata: -> 메타데이터
* spec: -> 리소스 내용

### 리소스 설정(API 그룹 및 유형)

* 리소스를 정의하려면 먼저 API 그룹과 리소스 유형을 지정해야 함
* 레플리카세트

<table><thead><tr><th width="160">리소스</th><th>API 그룹 / 버전</th><th>리소스 유형</th></tr></thead><tbody><tr><td>파드</td><td>v1</td><td>Pod</td></tr><tr><td>서비스</td><td>v1</td><td>Service</td></tr><tr><td>디플로이먼트</td><td>apps/v1</td><td>Deployment</td></tr><tr><td>레플리카세트</td><td>apps/v1</td><td>ReplicaSet</td></tr></tbody></table>

### 메타데이터와 스펙

* 메타데이터에는 리소스의 이름이나 레이블 기재
* 스펙은 리소스의 내용을 정의, 어떤 리소스를 만들 것인가에 해당하는 부분

### 레이블과 셀렉터

* 파드나 서비스 같은 리소스에 원하는 레이블을 붙일 수 있음
* 레이블은 키-값 형태로 메타데이터로 설정
* 레이블을 부여하면 셀렉터 기능을 사용해 특정 레이블이 부여된 파드만을 배포하는 등 특정 파드를 선택해 설정할 수 있음

## 메타데이터와 스펙 작성 - 파드

* 파드는 단독으로 매니페스트 파일이 기재되는 경우가 드물고, 대부분 디플로이먼트에 포함되는 형태로 기재됨
* containers 항목의 name은 컨테이너 이름이고, metadata 항목의 name은 파드의 이름

```docker
metadata:
 name: // 파드의 이름
 labels: // 레이블
spec:
 containers: // 컨테이너 구성
  - name: // 컨테이너 이름
    image: // 이미지 이름
    ports: // 포트 설정
```
